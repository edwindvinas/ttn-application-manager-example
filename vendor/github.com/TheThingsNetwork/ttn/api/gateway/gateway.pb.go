// Code generated by protoc-gen-gogo.
// source: github.com/TheThingsNetwork/ttn/api/gateway/gateway.proto
// DO NOT EDIT!

/*
	Package gateway is a generated protocol buffer package.

	It is generated from these files:
		github.com/TheThingsNetwork/ttn/api/gateway/gateway.proto

	It has these top-level messages:
		GPSMetadata
		RxMetadata
		TxConfiguration
		Status
*/
package gateway

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type GPSMetadata struct {
	Time      int64   `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Latitude  float32 `protobuf:"fixed32,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude float32 `protobuf:"fixed32,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Altitude  int32   `protobuf:"varint,4,opt,name=altitude,proto3" json:"altitude,omitempty"`
}

func (m *GPSMetadata) Reset()                    { *m = GPSMetadata{} }
func (m *GPSMetadata) String() string            { return proto.CompactTextString(m) }
func (*GPSMetadata) ProtoMessage()               {}
func (*GPSMetadata) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{0} }

type RxMetadata struct {
	GatewayId string       `protobuf:"bytes,1,opt,name=gateway_id,json=gatewayId,proto3" json:"gateway_id,omitempty"`
	Timestamp uint32       `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Time      int64        `protobuf:"varint,12,opt,name=time,proto3" json:"time,omitempty"`
	RfChain   uint32       `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	Channel   uint32       `protobuf:"varint,22,opt,name=channel,proto3" json:"channel,omitempty"`
	Frequency uint64       `protobuf:"varint,31,opt,name=frequency,proto3" json:"frequency,omitempty"`
	Rssi      float32      `protobuf:"fixed32,32,opt,name=rssi,proto3" json:"rssi,omitempty"`
	Snr       float32      `protobuf:"fixed32,33,opt,name=snr,proto3" json:"snr,omitempty"`
	Gps       *GPSMetadata `protobuf:"bytes,41,opt,name=gps" json:"gps,omitempty"`
}

func (m *RxMetadata) Reset()                    { *m = RxMetadata{} }
func (m *RxMetadata) String() string            { return proto.CompactTextString(m) }
func (*RxMetadata) ProtoMessage()               {}
func (*RxMetadata) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{1} }

func (m *RxMetadata) GetGps() *GPSMetadata {
	if m != nil {
		return m.Gps
	}
	return nil
}

type TxConfiguration struct {
	Timestamp             uint32 `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	RfChain               uint32 `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	Frequency             uint64 `protobuf:"varint,22,opt,name=frequency,proto3" json:"frequency,omitempty"`
	Power                 int32  `protobuf:"varint,23,opt,name=power,proto3" json:"power,omitempty"`
	PolarizationInversion bool   `protobuf:"varint,31,opt,name=polarization_inversion,json=polarizationInversion,proto3" json:"polarization_inversion,omitempty"`
	FrequencyDeviation    uint32 `protobuf:"varint,32,opt,name=frequency_deviation,json=frequencyDeviation,proto3" json:"frequency_deviation,omitempty"`
}

func (m *TxConfiguration) Reset()                    { *m = TxConfiguration{} }
func (m *TxConfiguration) String() string            { return proto.CompactTextString(m) }
func (*TxConfiguration) ProtoMessage()               {}
func (*TxConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{2} }

// message Status represents a status update from a Gateway.
type Status struct {
	Timestamp    uint32            `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Time         int64             `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	Ip           []string          `protobuf:"bytes,11,rep,name=ip" json:"ip,omitempty"`
	Platform     string            `protobuf:"bytes,12,opt,name=platform,proto3" json:"platform,omitempty"`
	ContactEmail string            `protobuf:"bytes,13,opt,name=contact_email,json=contactEmail,proto3" json:"contact_email,omitempty"`
	Description  string            `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	Region       string            `protobuf:"bytes,15,opt,name=region,proto3" json:"region,omitempty"`
	Bridge       string            `protobuf:"bytes,16,opt,name=bridge,proto3" json:"bridge,omitempty"`
	Router       string            `protobuf:"bytes,17,opt,name=router,proto3" json:"router,omitempty"`
	Gps          *GPSMetadata      `protobuf:"bytes,21,opt,name=gps" json:"gps,omitempty"`
	Rtt          uint32            `protobuf:"varint,31,opt,name=rtt,proto3" json:"rtt,omitempty"`
	RxIn         uint32            `protobuf:"varint,41,opt,name=rx_in,json=rxIn,proto3" json:"rx_in,omitempty"`
	RxOk         uint32            `protobuf:"varint,42,opt,name=rx_ok,json=rxOk,proto3" json:"rx_ok,omitempty"`
	TxIn         uint32            `protobuf:"varint,43,opt,name=tx_in,json=txIn,proto3" json:"tx_in,omitempty"`
	TxOk         uint32            `protobuf:"varint,44,opt,name=tx_ok,json=txOk,proto3" json:"tx_ok,omitempty"`
	Os           *Status_OSMetrics `protobuf:"bytes,51,opt,name=os" json:"os,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{3} }

func (m *Status) GetGps() *GPSMetadata {
	if m != nil {
		return m.Gps
	}
	return nil
}

func (m *Status) GetOs() *Status_OSMetrics {
	if m != nil {
		return m.Os
	}
	return nil
}

// Additional metrics from the operating system
type Status_OSMetrics struct {
	Load_1           float32 `protobuf:"fixed32,1,opt,name=load_1,json=load1,proto3" json:"load_1,omitempty"`
	Load_5           float32 `protobuf:"fixed32,2,opt,name=load_5,json=load5,proto3" json:"load_5,omitempty"`
	Load_15          float32 `protobuf:"fixed32,3,opt,name=load_15,json=load15,proto3" json:"load_15,omitempty"`
	CpuPercentage    float32 `protobuf:"fixed32,11,opt,name=cpu_percentage,json=cpuPercentage,proto3" json:"cpu_percentage,omitempty"`
	MemoryPercentage float32 `protobuf:"fixed32,21,opt,name=memory_percentage,json=memoryPercentage,proto3" json:"memory_percentage,omitempty"`
	Temperature      float32 `protobuf:"fixed32,31,opt,name=temperature,proto3" json:"temperature,omitempty"`
}

func (m *Status_OSMetrics) Reset()                    { *m = Status_OSMetrics{} }
func (m *Status_OSMetrics) String() string            { return proto.CompactTextString(m) }
func (*Status_OSMetrics) ProtoMessage()               {}
func (*Status_OSMetrics) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{3, 0} }

func init() {
	proto.RegisterType((*GPSMetadata)(nil), "gateway.GPSMetadata")
	proto.RegisterType((*RxMetadata)(nil), "gateway.RxMetadata")
	proto.RegisterType((*TxConfiguration)(nil), "gateway.TxConfiguration")
	proto.RegisterType((*Status)(nil), "gateway.Status")
	proto.RegisterType((*Status_OSMetrics)(nil), "gateway.Status.OSMetrics")
}
func (m *GPSMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPSMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Time))
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Latitude))))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Longitude))))
	}
	if m.Altitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Altitude))
	}
	return i, nil
}

func (m *RxMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RxMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GatewayId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.GatewayId)))
		i += copy(dAtA[i:], m.GatewayId)
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
	}
	if m.Time != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Time))
	}
	if m.RfChain != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RfChain))
	}
	if m.Channel != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Channel))
	}
	if m.Frequency != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Frequency))
	}
	if m.Rssi != 0 {
		dAtA[i] = 0x85
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Rssi))))
	}
	if m.Snr != 0 {
		dAtA[i] = 0x8d
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Snr))))
	}
	if m.Gps != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Gps.Size()))
		n1, err := m.Gps.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *TxConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
	}
	if m.RfChain != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RfChain))
	}
	if m.Frequency != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Frequency))
	}
	if m.Power != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Power))
	}
	if m.PolarizationInversion {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.PolarizationInversion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FrequencyDeviation != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.FrequencyDeviation))
	}
	return i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Time))
	}
	if len(m.Ip) > 0 {
		for _, s := range m.Ip {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.ContactEmail) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ContactEmail)))
		i += copy(dAtA[i:], m.ContactEmail)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.Bridge) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Bridge)))
		i += copy(dAtA[i:], m.Bridge)
	}
	if len(m.Router) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Router)))
		i += copy(dAtA[i:], m.Router)
	}
	if m.Gps != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Gps.Size()))
		n2, err := m.Gps.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Rtt != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Rtt))
	}
	if m.RxIn != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.TxOk))
	}
	if m.Os != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Os.Size()))
		n3, err := m.Os.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Status_OSMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_OSMetrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Load_1 != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Load_1))))
	}
	if m.Load_5 != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Load_5))))
	}
	if m.Load_15 != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Load_15))))
	}
	if m.CpuPercentage != 0 {
		dAtA[i] = 0x5d
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.CpuPercentage))))
	}
	if m.MemoryPercentage != 0 {
		dAtA[i] = 0xad
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.MemoryPercentage))))
	}
	if m.Temperature != 0 {
		dAtA[i] = 0xfd
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Temperature))))
	}
	return i, nil
}

func encodeFixed64Gateway(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Gateway(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGateway(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GPSMetadata) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Altitude != 0 {
		n += 1 + sovGateway(uint64(m.Altitude))
	}
	return n
}

func (m *RxMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.GatewayId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if m.RfChain != 0 {
		n += 2 + sovGateway(uint64(m.RfChain))
	}
	if m.Channel != 0 {
		n += 2 + sovGateway(uint64(m.Channel))
	}
	if m.Frequency != 0 {
		n += 2 + sovGateway(uint64(m.Frequency))
	}
	if m.Rssi != 0 {
		n += 6
	}
	if m.Snr != 0 {
		n += 6
	}
	if m.Gps != nil {
		l = m.Gps.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *TxConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.RfChain != 0 {
		n += 2 + sovGateway(uint64(m.RfChain))
	}
	if m.Frequency != 0 {
		n += 2 + sovGateway(uint64(m.Frequency))
	}
	if m.Power != 0 {
		n += 2 + sovGateway(uint64(m.Power))
	}
	if m.PolarizationInversion {
		n += 3
	}
	if m.FrequencyDeviation != 0 {
		n += 2 + sovGateway(uint64(m.FrequencyDeviation))
	}
	return n
}

func (m *Status) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if len(m.Ip) > 0 {
		for _, s := range m.Ip {
			l = len(s)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ContactEmail)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Bridge)
	if l > 0 {
		n += 2 + l + sovGateway(uint64(l))
	}
	l = len(m.Router)
	if l > 0 {
		n += 2 + l + sovGateway(uint64(l))
	}
	if m.Gps != nil {
		l = m.Gps.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	if m.Rtt != 0 {
		n += 2 + sovGateway(uint64(m.Rtt))
	}
	if m.RxIn != 0 {
		n += 2 + sovGateway(uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		n += 2 + sovGateway(uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		n += 2 + sovGateway(uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		n += 2 + sovGateway(uint64(m.TxOk))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *Status_OSMetrics) Size() (n int) {
	var l int
	_ = l
	if m.Load_1 != 0 {
		n += 5
	}
	if m.Load_5 != 0 {
		n += 5
	}
	if m.Load_15 != 0 {
		n += 5
	}
	if m.CpuPercentage != 0 {
		n += 5
	}
	if m.MemoryPercentage != 0 {
		n += 6
	}
	if m.Temperature != 0 {
		n += 6
	}
	return n
}

func sovGateway(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGateway(x uint64) (n int) {
	return sovGateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GPSMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPSMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPSMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Longitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			m.Altitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Altitude |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RxMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RxMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RxMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Rssi = float32(math.Float32frombits(v))
		case 33:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Snr = float32(math.Float32frombits(v))
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gps == nil {
				m.Gps = &GPSMetadata{}
			}
			if err := m.Gps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolarizationInversion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PolarizationInversion = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyDeviation", wireType)
			}
			m.FrequencyDeviation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyDeviation |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = append(m.Ip, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bridge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Router = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gps == nil {
				m.Gps = &GPSMetadata{}
			}
			if err := m.Gps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxIn", wireType)
			}
			m.RxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxIn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxOk", wireType)
			}
			m.RxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxOk |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			m.TxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxIn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOk", wireType)
			}
			m.TxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxOk |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &Status_OSMetrics{}
			}
			if err := m.Os.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_OSMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Load_1 = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_5", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Load_5 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_15", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Load_15 = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.CpuPercentage = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.MemoryPercentage = float32(math.Float32frombits(v))
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Temperature = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGateway(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGateway
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGateway(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGateway = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGateway   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/TheThingsNetwork/ttn/api/gateway/gateway.proto", fileDescriptorGateway)
}

var fileDescriptorGateway = []byte{
	// 727 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0xe3, 0x44,
	0x1c, 0xc7, 0xce, 0x57, 0x33, 0xd9, 0x74, 0xbb, 0xb3, 0x9b, 0xec, 0xb4, 0x82, 0x60, 0x82, 0x40,
	0x29, 0x85, 0x44, 0xa5, 0xca, 0x81, 0x03, 0x17, 0x0a, 0x42, 0x3d, 0x40, 0xab, 0x69, 0x4f, 0x5c,
	0xac, 0x89, 0x3d, 0x71, 0x46, 0xb1, 0x67, 0xcc, 0x78, 0xdc, 0xa4, 0x3c, 0x09, 0x8f, 0xd4, 0x23,
	0x8f, 0x80, 0x8a, 0xc4, 0x3b, 0x70, 0x41, 0x68, 0xfe, 0x76, 0x5c, 0x17, 0x09, 0xaa, 0x3d, 0x79,
	0x7e, 0x1f, 0xe3, 0xff, 0xa7, 0x06, 0x7d, 0x15, 0x09, 0xb3, 0xca, 0x17, 0xd3, 0x40, 0x25, 0xb3,
	0x9b, 0x15, 0xbf, 0x59, 0x09, 0x19, 0x65, 0x3f, 0x72, 0xb3, 0x51, 0x7a, 0x3d, 0x33, 0x46, 0xce,
	0x58, 0x2a, 0x66, 0x11, 0x33, 0x7c, 0xc3, 0xee, 0x76, 0xdf, 0x69, 0xaa, 0x95, 0x51, 0xb8, 0x53,
	0xc2, 0xa3, 0x2f, 0x6a, 0xff, 0x88, 0x54, 0xa4, 0x66, 0xa0, 0x2f, 0xf2, 0x25, 0x20, 0x00, 0x70,
	0x2a, 0xee, 0x8d, 0x37, 0xa8, 0xf7, 0xfd, 0xd5, 0xf5, 0x0f, 0xdc, 0xb0, 0x90, 0x19, 0x86, 0x31,
	0x6a, 0x1a, 0x91, 0x70, 0xe2, 0x78, 0xce, 0xa4, 0x41, 0xe1, 0x8c, 0x8f, 0xd0, 0x5e, 0xcc, 0x8c,
	0x30, 0x79, 0xc8, 0x89, 0xeb, 0x39, 0x13, 0x97, 0x56, 0x18, 0xbf, 0x8f, 0xba, 0xb1, 0x92, 0x51,
	0x21, 0x36, 0x40, 0x7c, 0x24, 0xec, 0x4d, 0x16, 0x97, 0x37, 0x9b, 0x9e, 0x33, 0x69, 0xd1, 0x0a,
	0x8f, 0xff, 0x76, 0x10, 0xa2, 0xdb, 0x2a, 0xf0, 0x07, 0x08, 0x95, 0x15, 0xf8, 0x22, 0x84, 0xf0,
	0x5d, 0xda, 0x2d, 0x99, 0x8b, 0xd0, 0xc6, 0xb1, 0xb9, 0x64, 0x86, 0x25, 0x29, 0xe9, 0x79, 0xce,
	0xa4, 0x4f, 0x1f, 0x89, 0x2a, 0xeb, 0x17, 0xb5, 0xac, 0x0f, 0xd1, 0x9e, 0x5e, 0xfa, 0xc1, 0x8a,
	0x09, 0x49, 0x06, 0x70, 0xa1, 0xa3, 0x97, 0xe7, 0x16, 0x62, 0x82, 0x3a, 0xc1, 0x8a, 0x49, 0xc9,
	0x63, 0x32, 0x2c, 0x94, 0x12, 0xda, 0x30, 0x4b, 0xcd, 0x7f, 0xce, 0xb9, 0x0c, 0xee, 0xc8, 0x87,
	0x9e, 0x33, 0x69, 0xd2, 0x47, 0xc2, 0x86, 0xd1, 0x59, 0x26, 0x88, 0x07, 0x75, 0xc2, 0x19, 0x1f,
	0xa0, 0x46, 0x26, 0x35, 0xf9, 0x08, 0x28, 0x7b, 0xc4, 0x9f, 0xa2, 0x46, 0x94, 0x66, 0xe4, 0xd8,
	0x73, 0x26, 0xbd, 0x2f, 0xdf, 0x4c, 0x77, 0x63, 0xaa, 0x75, 0x99, 0x5a, 0xc3, 0xf8, 0x4f, 0x07,
	0xbd, 0xbc, 0xd9, 0x9e, 0x2b, 0xb9, 0x14, 0x51, 0xae, 0x99, 0x11, 0x4a, 0x3e, 0x53, 0xe6, 0xff,
	0x94, 0xf4, 0x24, 0xf1, 0xe1, 0xbf, 0x13, 0x7f, 0x83, 0x5a, 0xa9, 0xda, 0x70, 0x4d, 0xde, 0xc2,
	0x10, 0x0a, 0x80, 0xe7, 0x68, 0x98, 0xaa, 0x98, 0x69, 0xf1, 0x0b, 0x04, 0xf7, 0x85, 0xbc, 0xe5,
	0x3a, 0x13, 0x4a, 0x42, 0xe5, 0x7b, 0x74, 0x50, 0x57, 0x2f, 0x76, 0x22, 0x9e, 0xa1, 0xd7, 0xd5,
	0x9f, 0xfd, 0x90, 0xdf, 0x0a, 0xd0, 0xa1, 0x29, 0x7d, 0x8a, 0x2b, 0xe9, 0xdb, 0x9d, 0x32, 0xfe,
	0xab, 0x89, 0xda, 0xd7, 0x86, 0x99, 0x3c, 0x7b, 0x5a, 0x9f, 0xf3, 0x5f, 0x63, 0x74, 0x6b, 0x63,
	0xdc, 0x47, 0xae, 0xb0, 0xad, 0x68, 0x4c, 0xba, 0xd4, 0x15, 0xa9, 0x5d, 0xa9, 0x34, 0x66, 0x66,
	0xa9, 0x74, 0x02, 0xe3, 0xee, 0xd2, 0x0a, 0xe3, 0x8f, 0x51, 0x3f, 0x50, 0xd2, 0xb0, 0xc0, 0xf8,
	0x3c, 0x61, 0x22, 0x26, 0x7d, 0x30, 0xbc, 0x28, 0xc9, 0xef, 0x2c, 0x87, 0x3d, 0xd4, 0x0b, 0x79,
	0x16, 0x68, 0x91, 0x42, 0xda, 0xfb, 0x60, 0xa9, 0x53, 0x78, 0x88, 0xda, 0x9a, 0x47, 0x56, 0x7c,
	0x09, 0x62, 0x89, 0x2c, 0xbf, 0xd0, 0x22, 0x8c, 0x38, 0x39, 0x28, 0xf8, 0x02, 0x81, 0x5f, 0xe5,
	0x86, 0x6b, 0xf2, 0xaa, 0xf4, 0x03, 0xda, 0x2d, 0xc2, 0xe0, 0x99, 0x45, 0xb0, 0x2b, 0xa4, 0x8d,
	0x81, 0xa6, 0xf7, 0xa9, 0x3d, 0xe2, 0xd7, 0xa8, 0xa5, 0xb7, 0xbe, 0x90, 0xb0, 0x44, 0x7d, 0xda,
	0xd4, 0xdb, 0x0b, 0x59, 0x92, 0x6a, 0x4d, 0x3e, 0xdb, 0x91, 0x97, 0x6b, 0x4b, 0x1a, 0x70, 0x9e,
	0x14, 0xa4, 0x29, 0x9d, 0x06, 0x9c, 0x9f, 0xef, 0xc8, 0xcb, 0x35, 0x3e, 0x46, 0xae, 0xca, 0xc8,
	0x19, 0x24, 0x73, 0x58, 0x25, 0x53, 0xcc, 0x65, 0x7a, 0x69, 0x53, 0xd2, 0x22, 0xc8, 0xa8, 0xab,
	0xb2, 0xa3, 0x7b, 0x07, 0x75, 0x2b, 0x06, 0x0f, 0x50, 0x3b, 0x56, 0x2c, 0xf4, 0x4f, 0x61, 0x60,
	0x2e, 0x6d, 0x59, 0x74, 0x5a, 0xd1, 0xf3, 0xf2, 0x4d, 0x00, 0x7a, 0x8e, 0xdf, 0xa2, 0x4e, 0xe1,
	0x9e, 0x97, 0xcf, 0x01, 0xb8, 0x4e, 0xe7, 0xf8, 0x13, 0xb4, 0x1f, 0xa4, 0xb9, 0x9f, 0x72, 0x1d,
	0x70, 0x69, 0x58, 0xc4, 0x61, 0xbf, 0x5d, 0xda, 0x0f, 0xd2, 0xfc, 0xaa, 0x22, 0xf1, 0x09, 0x7a,
	0x95, 0xf0, 0x44, 0xe9, 0xbb, 0xba, 0x73, 0x00, 0xce, 0x83, 0x42, 0xa8, 0x99, 0x3d, 0xd4, 0x33,
	0x3c, 0x49, 0xb9, 0x66, 0x26, 0xd7, 0x1c, 0x3a, 0xe8, 0xd2, 0x3a, 0xf5, 0xcd, 0xd7, 0xf7, 0x0f,
	0x23, 0xe7, 0xb7, 0x87, 0x91, 0xf3, 0xfb, 0xc3, 0xc8, 0xf9, 0xf5, 0x8f, 0xd1, 0x7b, 0x3f, 0x9d,
	0xbc, 0xc3, 0x1b, 0xbb, 0x68, 0xc3, 0x23, 0x79, 0xf6, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x79,
	0xa3, 0xfb, 0x4d, 0x99, 0x05, 0x00, 0x00,
}
